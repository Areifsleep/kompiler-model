SHLAER-MELLOR OBJECT ORIENTED ANALYSIS RULES
Source: Software Engineering Notes, ACM Press, Volume 18, Number 1, January 1993

--- SUBSYSTEMS ---
1. A large domain may be analyzed by partitioning it into a set of subsystems. [cite: 18]
2. Each subsystem must have a unique name. [cite: 19]
3. The complete information model for the domain will be partitioned into multiple smaller information models. [cite: 20]
4. Each information model is assigned to a separate subsystem. [cite: 21]

--- INFORMATION MODEL ---
5. Each object belongs to one and only one subsystem. [cite: 47]
6. Each object in a subsystem must have a unique name. Objects must also be numbered uniquely. [cite: 48, 49]
7. Each object must have a unique KeyLetter. [cite: 50]
8. Each attribute within an object must have a unique name (form: <object>.<attribute>). [cite: 51]
9. Each object must have at least one identifier (attribute or set of attributes). [cite: 53]
   (Note: Each relationship in a subsystem must have a unique label of the form Rn). [cite: 55]
   (Note: Each relationship must be formalized through referential attributes or composition). [cite: 56]
10. Referential attributes are indicated by appending the label of the relationship to the attribute. [cite: 57]
11. The domain of a referential attribute must be the same as the domain of the corresponding attribute of the associated object. [cite: 58]
12. A relationship Ri formed by composition must be indicated as $Ri=Rj+Rk$. [cite: 59]
13. Each object, attribute, and relationship in a subsystem must be fully defined or described. Foreign objects do not have descriptions in the local IM. [cite: 60, 61]
14. A relationship between objects in different subsystems will appear in the IM for both subsystems but described in only one. [cite: 62, 63]

--- STATE MODELS ---
15. An object may have one state model formalizing the lifecycle of its instances. Name and KeyLetter match the object. [cite: 64, 65, 66]
16. An associative object may have an additional state model (<object>_ASSIGNER) to manage instance creation. [cite: 67, 68]
17. Each state model will have a unique name and KeyLetter. [cite: 71]
18. Each state within a state model must have a unique name. [cite: 72]
19. Each state within a state model is assigned a unique number. [cite: 77]
20. External entities (terminators) are assigned a unique KeyLetter across all entities/models in the subsystem. [cite: 78, 79]

--- TIMERS & EVENTS ---
21. An object named TIMER (KeyLetter TIM) is part of the formalism. It is not shown on the IM. [cite: 83, 84, 87]
22. Events are generated by state models and external entities. [cite: 88]
23. Events are received by state models and external entities. [cite: 89]
24. An event is directed towards one and only one state model or external entity (and specific instance if applicable). [cite: 95, 96]
25. An event is specified by event name, destination, and event data. [cite: 98]
26. An event label has the form: KLi (where KL is KeyLetter, i is integer). [cite: 100]
27. Events in state models use form: <Event_label>:<Incident_name> (<event_data>). [cite: 101, 102]
28. Events causing a transition to a new state must include an identifier of the instance in the event data. [cite: 103]
29. All events causing a transition into the same state must carry exactly the same event data. [cite: 104]
30. Defined TIMER events: TIM1: Set Timer(...) and TIM2: Reset Timer(...). [cite: 90]

--- OBJECT COMMUNICATION & ACTIONS ---
31. State models/entities generating or receiving events must appear on the Object Communication Model (OCM). [cite: 93]
32. Events generated by one entity and received by another must appear on the OCM. [cite: 94]
33. The TIMER state model and its events are NOT shown on the OCM. [cite: 110]
34. Each state in a state model has an action associated with it. [cite: 111]
35. An action modifying data must ensure self-consistency of the instance. [cite: 112]
36. Actions creating/deleting instances must ensure relationship consistency. [cite: 113]
37. An action must leave subtypes and supertypes consistently populated. [cite: 114]
38. Actions must update the current state attribute (except in deletion states). [cite: 116]

--- PROCESS MODELS (ADFD) ---
39. A process model represents the processing for the action associated with a state. [cite: 117]
40. Process models consist of processes, data flows, control flows, and data stores. [cite: 120, 121]
41. Data stores are labelled "Timer", "Current Time", or with the name of an object. [cite: 122]
42. "Timer" store represents time left on each timer. [cite: 123]
43. "Current Time" store represents current time data. [cite: 124]
44. Object data stores represent persistent data for all instances of that object. [cite: 125]
45. A data store may appear multiple times. [cite: 126]
46. Conditional control flows are labelled with circumstances. [cite: 127]
47. Unconditional control flows are unlabelled. [cite: 128]
48. Data flows must be labelled with the names of data elements. [cite: 129]
49. Data flows to/from object stores are labelled with attributes (object name optional). [cite: 130, 131]
50. Data flows between processes may be attributes or transient data. [cite: 132]
51. Transient data flows are labelled with variable name and "(transient)". [cite: 133]
52. Persistent data flows between processes are labelled with attribute names (ObjectP.attr1=ObjectC.attr2). [cite: 136, 137]
53. Incoming event data is shown as a data flow from nowhere, labelled with required attributes. [cite: 139, 140]
54. Outgoing events are shown as data flows to nowhere, labelled with event label and data. [cite: 141, 142]
55. Deletion of an instance is a flow to the object store labelled "(delete)". [cite: 143]
56. A process executes when all inputs are available. [cite: 145]
57. Outputs are available once the process completes. [cite: 148]
58. Event data causing the transition is always available. [cite: 149]
59. Data from data stores is always available. [cite: 150]
60. Each process must have a process identifier and meaningful name. [cite: 151]

--- PROCESS DECOMPOSITION ---
61. Complex processes should be partitioned into accessors, transformations, event generators, and tests. [cite: 153]
62. Processes carrying out the same function/IO are the same process and share identifiers. [cite: 158]
63. Process identifier form: KL.i (KL = KeyLetter, i = integer). [cite: 159]
64. Accessors are assigned the KeyLetter of the object accessed. [cite: 160]
65. Defined TIMER accessors: TIM.3 Create, TIM.4 Delete, TIM.5 Read Time Remaining. [cite: 161-165]
66. Transformations are assigned the KeyLetter of the state model. [cite: 166]
67. Event generators are assigned the KeyLetter of the target object/entity. [cite: 168, 169]
68. Defined TIMER event generators: TIM.1 Generate TIM1, TIM.2 Generate TIM2. [cite: 171, 172]
69. Test processes are assigned the KeyLetter of the state model. [cite: 173]

--- ACCESS & COMMUNICATION MODELS ---
70. If state model X accesses data of object Y, both appear on Object Access Model (arrow from X to Y). [cite: 175, 176]
71. All subsystems must appear on the Subsystem Communication Model. [cite: 177]
72. Events between subsystems must appear on the Subsystem Communication Model. [cite: 180]